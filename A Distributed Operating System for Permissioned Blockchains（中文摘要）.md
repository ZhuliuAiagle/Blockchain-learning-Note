# Fabric架构

## Fabric总览

### fabric应用包含以下部分
1. **智能合约**
2. **背书策略:**指定一批背书节点进行验证，验证之后进行排序，这一步通过共识算法实现，然后将结果广播到所有节点。

### fabric中的三种节点
1. **client：** 客户节点，提交交易提案；

2. **peer：** 背书节点，执行交易并验证交易,背书时被选中的节点就是peer。但最后全部peer都要完成账本的更新；

3. **OSN：** 排序服务节点，功能是建立起有交易的全序；每笔交易包含依赖还有用于计算背书节点的加密签名；它并不参与交易执行或是交易验证，也不知道应用的状态。

4. 注意：一台物理节点上可以运行很多扮演不同角色的节点；相对于peer，其他两者都是很少的存在；

### 信道
fabric支持多条并行，每条叫做信道；信道可以用来分隔区块链网络的状态，但是信道间的共识算法并不会做出相应调整，并且不同信道的交易全序也是不同的。

## 执行阶段

### 步骤
1. 客户向一个或多个背书节点发送交易提案；背书节点是通过背书策略**隐式**指定的.交易提案包括提交交易的客户身份（通过MSP获得）、执行操作形式的交易负载、参数、链码所有者的标识符、每个节点只用一次的现时标识（例如一个计数器或是一个随机数）和由链码标识符与现时标识生成的交易标识符。同样，客户还会对提案签名。

2. 背书节点通过预装链码执行操作模拟交易提案。链码在docker容器中运行，和背书进程相隔离；背书节点并不保存模拟交易后账本状态的改变。链码创建的状态仅限于这个链码，并不能被其他链码直接访问。需要注意的是，链码不应该在程序代码中储存本地状态，只储存它可以被**GetState**，**PutState**和**DelState**这几个操作访问的区块链状态。在给予一定权限的情况下，同一信道内的链码可以调用另一个链码去访问自己的状态。<br/>
模拟结束后，背书节点会加密生成一个叫做**背书**的信息，背书包含**读取集和写入集**（还有一些元数据例如交易ID，背书节点ID，背书节点的签名等），并把它们作为交易提案的回应发送回客户。客户节点会收集这些背书直到它们满足交易调用链码的背书策略的要求。特别是，这就要求**背书策略选取的所有节点对这笔交易必须产生相同的结果.**

3. 满足条件（也就是说背书策略）之后，客户创建这笔交易并把它传递给排序服务。

### 一些讨论
1. **不同背书节点之间结果不同？**先模拟运行可以进行验证；满足背书策略就行；
2. **非确定性链码？** 只能对他自己造成威胁；
3. **双花攻击？** 比特币中对同一个物品进行的2个修改操作是被禁止的；
4. **dos攻击？** 一个背书节点的本地策略怀疑有拒绝攻击（DoS）的可能性时可以很简单的终止交易执行;这在排序执行架构中是不可能实现的；

## 排序阶段

### 步骤
1. 客户收集到足够的背书，就会整合**交易**并提交给排序服务；交易信息包含了交易负载，交易元数据和一个背书集合。

2. 排序节点会先建立一个信道中所有被提交的交易全序。**尽管可能会有错误的排序**，排序节点依然会原子广播所有的背书并因此得以在这笔交易上建立共识。此外，排序服务会将多个交易在区块中分批处理并输出包含交易区块的哈希链。容错广播的一种常用方法是将交易组合或者是在不同区块中分批处理，这可以增加广播协议的吞吐量。

3. 排序服务接口只支持两种操作，被节点(peer）调用并被信道标识符隐秘地参数化：
    ```
    broadcast(tx)  // oper1
    B←deliver(s)   // oper2
    ```
    前者，客户调用这个操作把任意一个交易tx广播出去；
    后者，客户调用这个操作使用一个非负序列号s去寻找区块B。这个区块包含一系列交易[tx1...txk]和一个哈希值h代表了序号是s-1的区块，例如：

    ```
    B=([tx1...txk],h)
    ```
    
    **客户可能会重复调用这个操作，只要区块有效返回,值就是确定的，** 所以当节点通过第一次调用deliver(s)接收区块B时，之后**依然可以通过s接收到B。**
4. 排序保证信道的如下安全属性：一致性（区块序数和对应区块一一映射），哈希链完整性（若s获取到B，则是s+1获取到的B’={[tx...],h},h=Hash(B)），无跳跃性(如果一个**正确**节点p通过s>0返回了一个B，那么对于i=0,1,2,...s-1,节点p已经通过i返回了对应区块)，不会无中生有（若一个**正确**节点（peer）通过s返回B，那么B中每一个交易都被广播过了），以及合法性（如果一个正确客户调用了broadcast(tx)那么每个正确节点都会通过某序列号收到包含tx的区块B）。

5. 只有很少一部分节点实现排序服务但peer可以很多，Fabric可以设置使用内置的交流组件把排序节点接收的区块分发给所有的节点（peers, 4.3）。交流组件跟用什么排序服务无关，它可以同时和CFT，BFT合作；

6. 排序服务还可以执行访问权限检查来决定客户是否有权广播一些信息或是在给定信道上接收区块。

### 讨论
**排序服务不保存区块链的任何状态、验证和交易。** 这是十分重要的,使得Fabric第一个彻底分离了共识算法和交易验证的区块链系统。

## 验证阶段

### 步骤
1. **背书策略的评估** 在一个区块中所有的交易同时运行时进行。评估是所谓**验证系统链码（VSCC）** 的任务,它是区块链配置中的一个静态库，负责根据链码配置的相关背书策略来验证背书（4.6节）。**如果不满足背书条件，交易会被标记为非法并撤销它造成的所有改变。**

2. **读写争议判定** 在区块中线性执行。对于每个交易，首先比较**读取集**和节点本地储存的**当前账本**状态中键的版本 ，保证它们是相同的。假如版本不匹配，交易会被标记为非法并撤销它造成的所有改变。

3. **账本更新阶段**，这时区块会被追加在本地储存的账本中，更新了区块链的状态。特别的是，当为账本追加区块时，前两步中的验证检查的结果还以位掩码的形式保留着，来指明区块中这些交易是有效的。随后这可以帮助重建账本状态。此外，状态更新都是通过将所有的键值对放进写入集添加到本地状态中来完成的。

4. *补充:* Fabric中默认的VSCC允许使用**逻辑单调表达式**去表示链码上的背书节点集。当交易背书的有效签名满足这个表达式时，VSCC评估就会验证通过这个节点集。不同的VSCC策略可以被静态设置

### 讨论
**可能包含非法交易的原因** （1）链码对排序节点不可知；（2）验证过程是在已经达成共识后完成的。这实际上是一个好设计，因为它可以再审计中追踪非法交易。（比特币和以太坊都没有上述功能）

**Peer节点的组成(从上到下)** 背书功能区：执行链码并承担容器的角色；提交功能区:负责验证、组态（构造），存储系统链码；账本：存储区块，peer trans.manager(PTM),KVS:数据库；点对点交流：负责peer之间的交流。

---

# Fabric 组件

## 成员管理服务（MSP）
负责保存系统中所有物理节点的身份，包括客户，节点和排序服务节点，并负责为节点发布认证和授权时需要的凭证。
为CAs(证书颁发机构)提供准入空间
其他功能：可以验证交易、检验交易完整性、签署背书、验证背书和核验其他的区块链操作。那些管理键和负责注册节点的工具也是MSP的一部分。
由**每个节点**的部分组件组成

## 排序服务
1.原子广播实现了broadcast和deliver的方法调用，在所有的交易中建立排序。

2.信道的重新配置，当信道的成员通过广播一个配置交易来更新配置。

3.可选地，访问限制，是在那些排序服务扮演可信任实体的配置中，限制特定节点和客户广播交易和接收区块。

排序服务是在系统信道上通过创世区块自己生成的。

一个区块在满足以下任意一个条件时立刻被切分：

* 区块包含交易数达到上限
* 区块在字节内存上已经达到上限
* 距离接收新区块的第一个交易的时间点，交易已经超时
## 通信组件
分离执行、排序、验证阶段的**好处**之一是它们可以被**独立地延展**。然而，由于大多数的共识算法（CFT和BFT模型）都有带宽约束，排序服务的吞吐量上限由节点的网络状况决定。**共识算法并不能通过增加更多的节点来延展，因为这样将会降低吞吐量。**然而，由于解耦了排序和验证阶段，在排序阶段后，我们对如何高效地向节点广播交易执行结果来进行**验证**更感兴趣。这就是通信组件最重要的目标，为了达成这一目标它使用了**蔓延组播（epidemic multicast）**。区块都是被排序服务节点签署的，意味着任何一个节点可以通过接收所有的区块，独立的组装一个区块链并验证其完整性。

Fabric网络通过通信组件散布信息是非常健壮的并且对节点错误具有抵抗力，这与覆盖（应用层）网络（overlay networks）形成对比。

通信组件的通讯层是基于gRPC的，并且通过彼此验证利用了TLS协议，这让每一边都可以将TLS证书绑定到远程节点的身份。

通信组件的主要目的是可靠地分发数据。

为了减少从排序节点向网络发送区块的负载，通信协议还会选举出一个领导节点代表其他节点从排序节点拉取区块并初始化通信组件。这个机制对于领导节点发送错误是有弹性的。

通信组件的另一个任务是将区块链的状态传递给新加入的节点，这个节点可能已经失联很长时间了。它们需要去接收区块链的所有区块。这个特性依赖于通过成员网络最长区块链的长度已经被分发给了所有的节点并储存。

## 账本
### 账本区块储存
账本区块仓库长期储存交易区块的数据，它是以一个可追加集合的形式实现的。由于区块是不可变的并且以恒定的顺序进入，这种可追加的结构能够发挥它最大的性能。另外，区块仓库会储存一些指向随机区块或者是区块中的一个交易的索引。

### 节点交易管理员(PTM)
PTM保存了版本化键值对数据库的最新状态。对于链码储存的每一个主键，它储存了一个（键，值，版本）形式的元祖，包含它最新的值val和最新的版本ver。版本包括区块的序列号和区块中这笔（保存了条目的）交易的序列号。这使得版本号是唯一的并且单调递增。

账本组件允许节点在更新账本时发生崩溃。在接收到新区块后，通过使用3.4节中提到的位掩码，PTM执行验证并在区块中标记这笔交易是否有效。然后账本将区块添加到账本储存中，并写入硬盘，随后更新区块索引。然后PTM会将写入集中有效交易的状态更改到本地版本化储存中。最终，它会计算并保存一个值的回滚点，这里记录了已经成功应用的区块链的最大长度。这个回滚点用来在崩溃后重建时，从保存的区块中恢复索引和最新的状态。
<img src="P2F5.png"/>

### 链码执行
* 支持编写链码的语言：Go，Java，Node.js
* 链码在Docker容器环境的分离进程中运行，这将链码和其他链码以及节点隔离开。这也简化了管理链码的生命周期（例如，启动，停止，废弃链码）。链码和节点通过gRPC信息通讯。通过这种松散的联结，节点实际上无法知道链码实现是使用的是什么编程语言。
* 系统链码在节点进程中运行

## 信道配置和系统链码
Fabric的基本行为是通过信道配置和特殊的链码（系统链码）来自定义的。

### 信道配置
回想信道可以组成逻辑上的区块链，特殊的配置区块可以保存了一些元数据来记录信道的配置。每个配置区块都包含一个完整的信道配置并且不包含任何其他的交易。每个区块链都会以一个配置区块开头，叫做创世区块，用来建立信道。这个信道配置包括：

* 参与节点的MSPs的定义

* OSNs的网络地址

* 共识算法实现和排序服务的公有配置，例如打包区块的大小和超时限制。

* 访问排序服务操作的规则（广播，接收）。

* 信道配置如何进行修改的规则。

这些信道的配置可以用信道配置更新交易来更新。这种交易包括所有需要更改的配置和签名。排序服务节点通过使用当前的配置检验修改使用的签名是否经过验证，来评估这个更新是否有效。然后排序节点生成一个新的配置区块，其中嵌入了新的配置以及配置更新交易。节点接收到这个区块后，检验是否经过当前配置的验证，如果有效，它们就会更新现有的配置。

### 系统链码

应用链码通过背书系统链码（ESCC）和验证系统链码（VSCC）来部署。这两种链码以一种对称的方式被选择调用，因此**ESCC的输出（背书）可能会被作为VSCC输入的一部分**。

ESCC的输入是一个交易提案和模拟执行的结果。如果结果满足条件，ESCC会产生一个回应，包括结果和背书。对于默认的ESCC而言，这个背书只是一个基于节点本地身份的签名。

VSCC的输入是交易本身，输出则是交易是否有效。对于默认的VSCC而言，收集背书并与链码指定的背书策略校对，就能验证交易是否有效。




